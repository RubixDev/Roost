(* predefined "lists"  *)
LETTER_ = 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J'
        | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T'
        | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | 'a' | 'b' | 'c' | 'd'
        | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n'
        | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x'
        | 'y' | 'z' | '_' ;
DIGIT   = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
CHAR    = ? any UTF8 character ? ;

(* tokens *)
eol         = ? line break ? | ';' ;
eof         = ? end of file ? ;
bool        = 'true' | 'false' ;
string      = '"' , { CHAR - '"' } , '"'
            | "'" , { CHAR - "'" } , "'" ;
identifier  = LETTER_ , { LETTER_ | DIGIT } ;
number      = DIGIT , { DIGIT } , [ '.' , DIGIT , { DIGIT } ] ;

(* expression nodes *)
Expression                  = TernaryExpression , [ ( '..' | '..=' ) , TernaryExpression ] ;
TernaryExpression           = OrExpression , [ '?' , Expression , ':' , Expression ] ;
OrExpression                = AndExpression , { '|' , AndExpression } ;
AndExpression               = EqualityExpression , { '&' , EqualityExpression } ;
EqualityExpression          = RelationalExpression , [ ( '==' | '!=' ) , RelationalExpression ] ;
RelationalExpression        = AdditiveExpression , [ ( '<' | '>' | '<=' | '>=' ) , AdditiveExpression ] ;
AdditiveExpression          = MultiplicativeExpression , { ( '+' | '-' ) , MultiplicativeExpression } ;
MultiplicativeExpression    = ExponentialExpression , { ( '*' | '/' ) , ExponentialExpression } ;
ExponentialExpression       = UnaryExpression , { '**' , UnaryExpression } ;
UnaryExpression             = ( '+' | '-' | '!' ) , UnaryExpression
                            | '(' , Expression , ')'
                            | Atom ;
Atom                        = number | bool | string | identifier | CallExpression | 'null' ;
Arguments                   = '(' , [ Expression , { ',' , Expression } ] , ')' ;
CallExpression              = identifier , Arguments ;

(* statement nodes *)
Statement           = DeclareStatement
                    | AssignStatement
                    | IfStatement
                    | LoopStatement
                    | WhileStatement
                    | ForStatement
                    | FunctionDeclaration
                    | Expression
                    | BreakStatement
                    | ContinueStatement
                    | ReturnStatement ;
DeclareStatement    = 'var' , identifier , '=' , Expression ;
AssignStatement     = identifier , ( '=' | '+=' | '-=' | '*=' | '/=' ) , Expression ;
IfStatement         = 'if' , '(' , Expression , ')' , Block , [ { eol } , 'else' , Block ] ;
LoopStatement       = 'loop' , Block ;
WhileStatement      = 'while' , '(' , Expression , ')' , Block ;
ForStatement        = 'for' , '(' , identifier , 'in' , Expression , ')' , Block ;
FunctionDeclaration = 'fun' , identifier , '(' , [ identifier , { ',' , identifier } ] , ')' , Block ;
BreakStatement      = 'break' ;
ContinueStatement   = 'continue' ;
ReturnStatement     = 'return' , [ Expression ] ;

(* other nodes *)
Statements  = { eol } , [ Statement , { eol , { eol } , Statement } ] , { eol } ;
Block       = { eol } , ( '{' , Statements , '}' | Statement ) ;
Program     = Statements , eof ;
